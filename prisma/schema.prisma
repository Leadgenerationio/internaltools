generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ─── Multi-tenancy ──────────────────────────────────────────

model Company {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan               Plan @default(FREE)
  monthlyBudgetCents Int? // Internal admin field — actual API cost cap (hidden from users)

  // Token system
  tokenBalance       Int  @default(0)  // Current available tokens
  monthlyTokenBudget Int?              // Optional: monthly token usage cap

  users             User[]
  projects          Project[]
  apiUsage          ApiUsageLog[]
  files             StorageFile[]
  tokenTransactions TokenTransaction[]
  tokenTopups       TokenTopup[]

  @@index([slug])
}

enum Plan {
  FREE
  STARTER
  PRO
  ENTERPRISE
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String?
  passwordHash String
  role         UserRole  @default(MEMBER)
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastLoginAt  DateTime?

  sessions          Session[]
  accounts          Account[]
  projects          Project[]
  apiUsage          ApiUsageLog[]
  tokenTransactions TokenTransaction[]
  tokenTopups       TokenTopup[]

  @@index([companyId])
  @@index([email])
}

enum UserRole {
  OWNER
  ADMIN
  MEMBER
}

// ─── NextAuth Tables ────────────────────────────────────────

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ─── Projects & Content ─────────────────────────────────────

model Project {
  id        String   @id @default(cuid())
  name      String
  companyId String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brief          Json? // AdBrief object
  overlayStyle   Json? // TextStyle object
  staggerSeconds Float  @default(2)
  renderQuality  String @default("final")

  ads      ProjectAd[]
  videos   ProjectVideo[]
  music    ProjectMusic?
  renders  RenderedOutput[]
  apiUsage ApiUsageLog[]

  @@index([companyId])
  @@index([userId])
}

model ProjectAd {
  id             String   @id @default(cuid())
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  funnelStage    String
  variationLabel String
  textBoxes      Json // Array of { id, text }
  approved       Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([projectId])
}

model ProjectVideo {
  id           String      @id @default(cuid())
  projectId    String
  project      Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  fileId       String
  file         StorageFile @relation(fields: [fileId], references: [id])
  originalName String
  duration     Float
  width        Int
  height       Int
  thumbnailUrl String?
  trimStart    Float?
  trimEnd      Float?
  createdAt    DateTime    @default(now())

  @@index([projectId])
}

model ProjectMusic {
  id        String      @id @default(cuid())
  projectId String      @unique
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  fileId    String
  file      StorageFile @relation(fields: [fileId], references: [id])
  name      String
  volume    Float       @default(0.5)
  startTime Float       @default(0)
  fadeIn    Float       @default(0)
  fadeOut   Float       @default(3)
}

model RenderedOutput {
  id           String      @id @default(cuid())
  projectId    String
  project      Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  adLabel      String
  originalName String
  fileId       String
  file         StorageFile @relation(fields: [fileId], references: [id])
  createdAt    DateTime    @default(now())

  @@index([projectId])
}

// ─── File Storage ───────────────────────────────────────────

model StorageFile {
  id          String   @id @default(cuid())
  companyId   String
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  storagePath String
  publicUrl   String
  sizeBytes   BigInt
  mimeType    String?
  createdAt   DateTime @default(now())

  projectVideos   ProjectVideo[]
  projectMusic    ProjectMusic[]
  renderedOutputs RenderedOutput[]

  @@index([companyId])
}

// ─── API Cost Tracking ──────────────────────────────────────

model ApiUsageLog {
  id        String  @id @default(cuid())
  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String
  user      User    @relation(fields: [userId], references: [id])
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  service  ApiService
  endpoint String
  model    String

  inputTokens  Int?
  outputTokens Int?
  videoSeconds Int?
  videoCount   Int?

  costCents    Int      // Internal: actual API cost in pence (hidden from users)
  tokensCost   Int?     // User-facing: how many tokens this operation cost
  durationMs   Int?
  success      Boolean  @default(true)
  errorMessage String?
  metadata     Json?

  createdAt DateTime @default(now())

  tokenTransaction TokenTransaction?

  @@index([companyId, createdAt])
  @@index([userId, createdAt])
  @@index([companyId, service, createdAt])
}

enum ApiService {
  ANTHROPIC
  GOOGLE_VEO
}

// ─── Token System ──────────────────────────────────────────

model TokenTransaction {
  id        String   @id @default(cuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])

  type         TokenTransactionType
  amount       Int    // Always positive; type indicates direction
  balanceAfter Int    // Snapshot of balance after this transaction

  reason      TokenReason
  description String?
  metadata    Json?

  // Link to API usage log for debits
  apiUsageLogId String?       @unique
  apiUsageLog   ApiUsageLog?  @relation(fields: [apiUsageLogId], references: [id])

  // Link to Stripe for purchases
  stripePaymentId String?

  createdAt DateTime  @default(now())
  expiresAt DateTime? // Plan tokens may expire at end of billing cycle

  @@index([companyId, createdAt])
  @@index([companyId, type, createdAt])
}

enum TokenTransactionType {
  CREDIT
  DEBIT
}

enum TokenReason {
  PLAN_ALLOCATION
  TOPUP_PURCHASE
  ADMIN_GRANT
  GENERATE_ADS
  GENERATE_VIDEO
  RENDER
  REFUND
  EXPIRY
  ADJUSTMENT
}

model TokenTopup {
  id        String   @id @default(cuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  tokenAmount     Int         // How many tokens purchased
  pricePence      Int         // How much they paid (in pence)
  stripeSessionId String?     @unique
  stripePaymentId String?
  status          TopupStatus @default(PENDING)

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([companyId, createdAt])
}

enum TopupStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}
